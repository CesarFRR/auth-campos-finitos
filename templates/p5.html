<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <title>Visualización Campo Finito - Cripto Login</title>

  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">

  <script>
    const rotateStartSoundURL = "{{ url_for('static', filename='rotate_start.mp3') }}";
    const rotateEndSoundURL = "{{ url_for('static', filename='rotate_end.mp3') }}";
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/addons/p5.sound.min.js"></script>
  <style>
    body {
      background: #181a1b;
      color: #f3f3f3;
    }

    #sketch-holder {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 2em;
    }

    /* Espaciado para los inputs y labels de p5 */
    .p5-input,
    .p5-label {
      margin-bottom: 10px !important;
      display: block !important;
    }

    .p5-label {
      margin-top: 18px !important;
    }
  </style>
</head>

<body>
  <div style="position: relative;">

    <a href="{{ url_for('auth.dashboard') }}" style="position: absolute; top: 0em; right: 1em; padding: 0.8em 2em; background-color: #1976d2; color: #fff; font-weight: bold; border-radius: 6px; text-decoration: none; box-shadow: 0 2px 8px rgba(25,118,210,0.15); transition: background 0.2s;">
        Ir a dashboard
    </a>
    
</div>
  <main>
    <h2 style="text-align:center; margin-top: 1em;">Visualización Interactiva de Campo Finito (Zp)</h2>
    <div id="sketch-holder"></div>
  </main>


  <script>


    let rotateStartSound;
    let rotateEndSound;
    // Variables para los elementos de entrada y valores
    let inputP, inputNum1, inputNum2;
    let modulusP = 7; // Valor inicial del módulo (p)
    let val1 = 3;     // Valor inicial del primer número (a)
    let val2 = 2;     // Valor inicial del segundo número (b)
    let sumResult;    // Resultado de la suma modular (a + b) mod p
    let multResult;   // Resultado de la multiplicación modular (a * b) mod p
    let animating = false;
    let animationStart = 0;
    let animationProgress = 0; // 0 a 1
    let animationType = "sum"; // "sum" o "mult"
    let animationSpeed = 0.5; // 1.0 = normal, <1 más lento, >1 más rápido (valor inicial más lento)
    let preSumTime = 0; // Tiempo de preanimación para la suma
    let managedSounds = [];
    let calculateButton, multButton;

    // Lista pre-calculada de los primeros 100 números primos para búsqueda rápida.
    const primeSet = new Set([
      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
      73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
      157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
      239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
      331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
      421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
      509, 521, 523, 541
    ]);
    const maxPrecomputedPrime = 541; // El primo más grande en nuestra lista.

    function preload() {
      soundFormats('mp3');

      // Usamos las variables globales definidas en p5.html
      rotateStartSound = loadSound(rotateStartSoundURL);
      rotateEndSound = loadSound(rotateEndSoundURL);
      managedSounds.push(rotateStartSound, rotateEndSound);
    }



    /**
     * Reproduce un sonido de forma segura, evitando que se ejecute si
     * otro sonido gestionado ya está sonando.
     * @param {p5.SoundFile} sound - El objeto de sonido de p5.js que se quiere reproducir.
     */
    function playSound(sound) {
      // Primero, verificar que el sonido exista y esté cargado.
      if (!sound || !sound.isLoaded()) {
        console.log("El sonido aún no está listo.");
        return;
      }

      // Segundo, recorrer la lista de sonidos gestionados.
      for (let s of managedSounds) {
        // Si algún sonido de la lista ya está sonando...
        if (s.isPlaying()) {
          // ...no hacer nada y salir de la función.
          return;
        }
      }

      // Si el bucle termina, significa que no hay sonidos en curso.
      // Ahora sí, reproducir el sonido solicitado.
      sound.play();
    }

    function setup() {
      let canvas = createCanvas(900, 600);
      canvas.parent('sketch-holder');
      background(220);

      textSize(18);
      textAlign(LEFT, CENTER);
      fill(0);

      let yPos = 20;
      let xPos = 20;

      createElement('h3', 'Configuración del Campo Finito (Zp)').position(xPos, yPos).addClass('p5-label');
      yPos += 40;

      createP('Módulo p (primo):').position(xPos, yPos).addClass('p5-label');
      yPos += 40; // Añadimos más espacio entre el label y el input
      inputP = createInput(modulusP.toString());
      inputP.position(xPos, yPos);
      inputP.input(updateValues);
      inputP.addClass('p5-input');
      yPos += 45; // Espacio extra después del input

      createP('Número 1 (a):').position(xPos, yPos).addClass('p5-label');
      yPos += 40;
      inputNum1 = createInput(val1.toString());
      inputNum1.position(xPos, yPos);
      inputNum1.input(updateValues);
      inputNum1.addClass('p5-input');
      yPos += 45;

      createP('Número 2 (b):').position(xPos, yPos).addClass('p5-label');
      yPos += 40;
      inputNum2 = createInput(val2.toString());
      inputNum2.position(xPos, yPos);
      inputNum2.input(updateValues);
      inputNum2.addClass('p5-input');
      yPos += 45;

      calculateButton = createButton('Calcular suma');
      calculateButton.position(xPos, yPos);
      calculateButton.mousePressed(() => triggerAnimation("sum"));
      yPos += 45;

      multButton = createButton('Calcular multiplicación');
      multButton.position(xPos, yPos);
      multButton.mousePressed(() => triggerAnimation("mult"));
      yPos += 45;

      let speedSlider = createSlider(0.1, 2, 0.5, 0.01); // mínimo más bajo y valor inicial más lento
      speedSlider.position(20, yPos + 50);
      speedSlider.style('width', '200px');
      speedSlider.input(() => {
        animationSpeed = speedSlider.value();
      });
      createP('Velocidad de animación').position(20, yPos + 10).addClass('p5-label');

      updateValues();
    }

    function triggerAnimation(type) {
      animating = true;
      animationStart = millis();
      animationProgress = 0;
      animationType = type || "sum"; // "sum" o "mult"
      updateValues();
      loop();
    }


    /**
     * Verifica si un número es primo, usando primero una lista rápida.
     * @param {number} num - El número a verificar.
     * @returns {boolean} - True si es primo, false si no lo es.
     */
    function fastIsPrime(num) {
      // Si el número está dentro del rango de nuestra lista rápida...
      if (num <= maxPrecomputedPrime) {
        // ...usamos la búsqueda súper rápida del Set.
        return primeSet.has(num);
      }

      // Si el número es más grande que los de la lista,
      // usamos la función de cálculo original como respaldo.
      return isPrime(num);
    }

    // (La función isPrime que ya tenías debe seguir existiendo en tu código)
    function isPrime(num) {
      if (num <= 1) return false;
      if (num <= 3) return true;
      if (num % 2 === 0 || num % 3 === 0) return false;
      for (let i = 5; i * i <= num; i = i + 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
      }
      return true;
    }
    function updateValues() {
      let newP_val = inputP.value();

      // Lógica de validación de número primo (esta parte se queda igual)
      if (newP_val === "") {
        modulusP = 2;
        inputP.style('border-color', '#ccc');
        inputNum1.removeAttribute('disabled');
        inputNum2.removeAttribute('disabled');
        calculateButton.removeAttribute('disabled');
        multButton.removeAttribute('disabled');
      } else {
        let newP = parseInt(newP_val);
        if (!isNaN(newP) && fastIsPrime(newP)) {
          modulusP = newP;
          inputP.style('border-color', 'green');
          inputNum1.removeAttribute('disabled');
          inputNum2.removeAttribute('disabled');
          calculateButton.removeAttribute('disabled');
          multButton.removeAttribute('disabled');
        } else {
          inputP.style('border-color', 'red');
          inputNum1.attribute('disabled', '');
          inputNum2.attribute('disabled', '');
          calculateButton.attribute('disabled', '');
          multButton.attribute('disabled', '');
          // Cuando p no es primo, salimos temprano y no tocamos los valores de a y b.
          return;
        }
      }

      // --- NUEVO: Lógica para conservar los valores de 'a' y 'b' ---

      // Validar Número 1 (a)
      let newNum1_val = inputNum1.value();
      if (newNum1_val === "") {
        val1 = 0;
      } else {
        let parsedNum1 = parseInt(newNum1_val);
        // Si el número es válido para el módulo actual, lo usamos.
        if (!isNaN(parsedNum1) && parsedNum1 >= 0 && parsedNum1 < modulusP) {
          val1 = parsedNum1;
          inputNum1.style('border-color', '#ccc'); // Color normal
        } else {
          // Si es inválido (ej: a >= p), NO lo reiniciamos a 0.
          // El valor interno 'val1' no se actualiza, conservando el último válido.
          // Marcamos el campo para notificar al usuario.
          inputNum1.style('border-color', 'orange');
        }
      }

      // Validar Número 2 (b)
      let newNum2_val = inputNum2.value();
      if (newNum2_val === "") {
        val2 = 0;
      } else {
        let parsedNum2 = parseInt(newNum2_val);
        // Si el número es válido para el módulo actual, lo usamos.
        if (!isNaN(parsedNum2) && parsedNum2 >= 0 && parsedNum2 < modulusP) {
          val2 = parsedNum2;
          inputNum2.style('border-color', '#ccc'); // Color normal
        } else {
          // Si es inválido, NO lo reiniciamos a 0.
          inputNum2.style('border-color', 'orange');
        }
      }

      // Los cálculos y el redibujado usan los últimos valores válidos conocidos.
      sumResult = (val1 + val2) % modulusP;
      multResult = (val1 * val2) % modulusP;

      redraw();
    }

    function draw() {
      background(220);



      drawModularClock();

      if (animating) {
        let duration = 1800 / animationSpeed;
        let pause = 350 / animationSpeed;
        let elapsed = millis() - animationStart;
        let progress = constrain(elapsed / duration, 0, 1);

        let p1 = 0.33;
        let p2 = p1 + (pause / duration);
        let p3 = 0.66 + (pause / duration);
        let p4 = 0.9 + (pause / duration);
        if (p4 > 0.9) p4 = 0.9;

        if (animationType === "sum") {
          animateSumPie(progress, p1, p2, p3, p4);
        }

        if (animationType === "mult") {
          animateMultPie(progress);
        }

        if (elapsed >= duration) {
          animating = false;
          noLoop();
        }
      }



      push(); // Guarda el estado actual de estilos
      fill(0);
      noStroke();
      textSize(20);
      textAlign(LEFT, CENTER);
      text(`Módulo (p): ${modulusP}`, 600, 50);
      text(`Número 1 (a): ${val1}`, 600, 80);
      text(`Número 2 (b): ${val2}`, 600, 110);

      fill(0, 150, 0);
      textAlign(RIGHT, CENTER);
      text(`Suma Modular (a + b) mod p: (${val1} + ${val2}) mod ${modulusP} = ${sumResult}`, 880, 160);
      text(`Multiplicación Modular (a * b) mod p: (${val1} * ${val2}) mod ${modulusP} = ${multResult}`, 880, 190);
      pop(); // Restaura el estado anterior de estilos
    }

    function drawModularClock() {
      let centerX = width / 2;
      let centerY = height / 2 + 100;
      let radius = 150;

      stroke(0);
      strokeWeight(2);
      noFill();
      ellipse(centerX, centerY, radius * 2, radius * 2);

      textSize(16);
      textAlign(CENTER, CENTER);
      fill(0);

      for (let i = 0; i < modulusP; i++) {
        let angle = map(i, 0, modulusP, 0, TWO_PI) - HALF_PI;
        let x = centerX + cos(angle) * (radius + 20);
        let y = centerY + sin(angle) * (radius + 20);
        text(i, x, y);

        let xInner = centerX + cos(angle) * radius;
        let yInner = centerY + sin(angle) * radius;
        let xOuter = centerX + cos(angle) * (radius + 10);
        let yOuter = centerY + sin(angle) * (radius + 10);
        line(xInner, yInner, xOuter, yOuter);
      }

      highlightNumber(val1, centerX, centerY, radius, color(255, 0, 0));
      highlightNumber(val2, centerX, centerY, radius, color(0, 0, 255));
      highlightNumber(sumResult, centerX, centerY, radius, color(0, 150, 0));
      highlightNumber(multResult, centerX, centerY, radius, color(200, 100, 0)); // Resaltar el resultado de la multiplicación modular

      drawLineToNumber(val1, centerX, centerY, radius, color(255, 0, 0, 100));
      drawLineToNumber(val2, centerX, centerY, radius, color(0, 0, 255, 100));
      drawLineToNumber(sumResult, centerX, centerY, radius, color(0, 150, 0, 100));
      drawLineToNumber(multResult, centerX, centerY, radius, color(200, 100, 0, 100)); // Línea para la multiplicación modular
    }

    function highlightNumber(num, centerX, centerY, radius, highlightColor) {
      if (num >= 0 && num < modulusP) {
        let angle = map(num, 0, modulusP, 0, TWO_PI) - HALF_PI;
        let x = centerX + cos(angle) * radius;
        let y = centerY + sin(angle) * radius;

        fill(highlightColor);
        noStroke();
        ellipse(x, y, 20, 20);
      }
    }

    function drawLineToNumber(num, centerX, centerY, radius, lineColor) {
      if (num >= 0 && num < modulusP) {
        let angle = map(num, 0, modulusP, 0, TWO_PI) - HALF_PI;
        let x = centerX + cos(angle) * radius;
        let y = centerY + sin(angle) * radius;

        stroke(lineColor);
        strokeWeight(3);
        line(centerX, centerY, x, y);
      }
    }

    function animateSumLine(progress) {
      let centerX = width / 2;
      let centerY = height / 2 + 100;
      let radius = 150;

      // Calcula los ángulos
      let angleA = map(val1, 0, modulusP, 0, TWO_PI) - HALF_PI;
      let angleB = map(val2, 0, modulusP, 0, TWO_PI) - HALF_PI;
      let angleSum = map(sumResult, 0, modulusP, 0, TWO_PI) - HALF_PI;

      // Punto de inicio (centro)
      let x0 = centerX;
      let y0 = centerY;

      // Punto de val1
      let x1 = centerX + cos(angleA) * radius;
      let y1 = centerY + sin(angleA) * radius;

      // Punto de sumResult
      let x2 = centerX + cos(angleSum) * radius;
      let y2 = centerY + sin(angleSum) * radius;

      stroke(0, 150, 0);
      strokeWeight(5);

      if (progress < 0.5) {
        // Animar desde centro a val1
        let t = map(progress, 0, 0.5, 0, 1);
        let xt = lerp(x0, x1, t);
        let yt = lerp(y0, y1, t);
        line(x0, y0, xt, yt);
      } else {
        // Animar desde val1 a sumResult
        line(x0, y0, x1, y1);
        let t = map(progress, 0.5, 1, 0, 1);
        let xt = lerp(x1, x2, t);
        let yt = lerp(y1, y2, t);
        line(x1, y1, xt, yt);
      }
    }

    function animateSumPie(progress) {
      push();
      let centerX = width / 2;
      let centerY = height / 2 + 100;
      let radius = 150;

      // --- Asignación de valores y colores ---
      let firstVal = Math.min(val1, val2);
      let secondVal = Math.max(val1, val2);
      let firstColor = (val1 <= val2) ? color(255, 0, 0, 150) : color(0, 0, 255, 150);
      let secondColor = (val1 > val2) ? color(255, 0, 0, 150) : color(0, 0, 255, 150);

      let angleFirst = map(firstVal, 0, modulusP, 0, TWO_PI);
      let angleSecond = map(secondVal, 0, modulusP, 0, TWO_PI);

      // --- Definición de las Fases de la Animación ---
      const phase1_end = 0.30; // Termina la animación del primer arco
      const phase2_end = 0.60; // Termina la animación del segundo arco
      const pause_end = 0.80;  // Termina la pausa (dura un 20% del total)
      const rotation_end = 1.0;  // Termina la rotación

      // --- Cálculo de los valores animados basado en el progreso ---

      // 1. Ángulo del primer arco
      let currentAngleFirst = (progress < phase1_end) ? lerp(0, angleFirst, progress / phase1_end) : angleFirst;

      // 2. Ángulo del segundo arco (solo se anima después de la fase 1)
      let currentAngleSecond = 0;
      if (progress > phase1_end) {
        let t = (progress - phase1_end) / (phase2_end - phase1_end);
        t = constrain(t, 0, 1); // Limita t entre 0 y 1
        currentAngleSecond = lerp(0, angleSecond, t);
      }

      // 3. Rotación (solo se anima después de la pausa)
      let rotationAngle = 0;
      if (progress > pause_end) {
        playSound(rotateStartSound);
        let t = (progress - pause_end) / (rotation_end - pause_end);
        t = constrain(t, 0, 1);
        rotationAngle = lerp(0, angleFirst, t);
      }

      // --- Dibujar los elementos en orden ---

      // Siempre dibuja el primer arco (rojo)
      fill(firstColor);
      noStroke();
      arc(centerX, centerY, radius * 2, radius * 2, -HALF_PI, -HALF_PI + currentAngleFirst, PIE);

      // Dibuja el segundo arco (azul) encima, aplicando la rotación
      if (currentAngleSecond > 0) {
        fill(secondColor);
        noStroke();
        let startAngle = -HALF_PI + rotationAngle;
        let endAngle = startAngle + currentAngleSecond;
        arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);
      }

      // Resalta el punto final solo cuando la animación ha terminado
      if (progress >= 1) {
        rotateStartSound.stop(); // Detiene el sonido de inicio si estaba sonando
        playSound(rotateEndSound);
        let angleSum = map((val1 + val2) % modulusP, 0, modulusP, 0, TWO_PI) - HALF_PI;
        let xSum = centerX + cos(angleSum) * radius;
        let ySum = centerY + sin(angleSum) * radius;
        noFill();
        stroke(0);
        strokeWeight(3);
        ellipse(xSum, ySum, 24, 24);
      }

      pop();
    }
    function animateMultPie(progress) {
      push();
      let centerX = width / 2;
      let centerY = height / 2 + 100;
      let radius = 150;

      let sliceVal = Math.min(val1, val2);
      let rotVal = Math.max(val1, val2);
      let angleSlice = map(sliceVal, 0, modulusP, 0, TWO_PI);

      // Definimos 3 fases: dibujar, pausar y rotar.
      let drawPhaseEnd = 0.35;   // El dibujo termina en el 35%
      let pausePhaseEnd = 0.55;  // La pausa termina en el 55% (dura un 20% del total)
      let rotatePhaseEnd = 1.0;    // La rotación ocupa el resto

      // Fase 1: Animar el trozo
      if (progress < drawPhaseEnd) {
        let t = progress / drawPhaseEnd; // Progreso dentro de esta fase (0 a 1)
        let endAngle = lerp(-HALF_PI, -HALF_PI + angleSlice, t);

        fill(255, 140, 0, 150);
        noStroke();
        arc(centerX, centerY, radius * 2, radius * 2, -HALF_PI, endAngle, PIE);

      }
      // Fase 2: Pausa (dibuja el arco completo pero sin movimiento)
      else if (progress < pausePhaseEnd) {
        let startAngle = -HALF_PI;
        let endAngle = startAngle + angleSlice;

        fill(255, 140, 0, 150);
        noStroke();
        arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);

      }
      // Fase 3: Rotar el trozo ya formado
      else {
        playSound(rotateStartSound);
        // Progreso dentro de esta fase (0 a 1)
        let t = (progress - pausePhaseEnd) / (rotatePhaseEnd - pausePhaseEnd);

        // --- INICIO DE LA CORRECCIÓN ---
        // Interpolamos el NÚMERO de la rotación, de la 1ª a la n-ésima (rotVal).
        let currentRotationStep = lerp(1, rotVal, t);

        // La posición inicial del arco es el número de la rotación MENOS UNO,
        // multiplicado por el tamaño del arco.
        let startAngle = -HALF_PI + (currentRotationStep - 1) * angleSlice;
        let endAngle = startAngle + angleSlice;
        // --- FIN DE LA CORRECCIÓN ---

        fill(255, 140, 0, 150);
        noStroke();
        arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);
      }

      // Resalta el resultado final cuando la animación completa termina
      if (progress >= 1) {
        rotateStartSound.stop(); // Detiene el sonido de inicio si estaba sonando
        playSound(rotateEndSound);
        let angleResult = map(multResult, 0, modulusP, 0, TWO_PI) - HALF_PI;
        let xRes = centerX + cos(angleResult) * radius;
        let yRes = centerY + sin(angleResult) * radius;

        noFill();
        stroke(0);
        strokeWeight(3);
        ellipse(xRes, yRes, 24, 24);
      }

      pop();
    }
  </script>
</body>

</html>