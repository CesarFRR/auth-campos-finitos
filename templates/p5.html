<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Visualización Campo Finito - Cripto Login</title>
            <script>
    const rotateStartSoundURL = "{{ url_for('static', filename='rotate_start.mp3') }}";
    const rotateEndSoundURL = "{{ url_for('static', filename='rotate_end.mp3') }}";
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/addons/p5.sound.min.js"></script>
    <style>
        body {
            background: #181a1b;
            color: #f3f3f3;
        }
        #sketch-holder {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 2em;
        }
        /* Espaciado para los inputs y labels de p5 */
        .p5-input, .p5-label {
            margin-bottom: 10px !important;
            display: block !important;
        }
        .p5-label {
            margin-top: 18px !important;
        }
    </style>
</head>
<body>
    <main>
        <h2 style="text-align:center; margin-top: 1em;">Visualización Interactiva de Campo Finito (Zp)</h2>
        <div id="sketch-holder"></div>
    </main>


    <script>


let rotateStartSound;
let rotateEndSound;
// Variables para los elementos de entrada y valores
let inputP, inputNum1, inputNum2;
let modulusP = 7; // Valor inicial del módulo (p)
let val1 = 3;     // Valor inicial del primer número (a)
let val2 = 2;     // Valor inicial del segundo número (b)
let sumResult;    // Resultado de la suma modular (a + b) mod p
let multResult;   // Resultado de la multiplicación modular (a * b) mod p
let animating = false;
let animationStart = 0;
let animationProgress = 0; // 0 a 1
let animationType = "sum"; // "sum" o "mult"
let animationSpeed = 0.5; // 1.0 = normal, <1 más lento, >1 más rápido (valor inicial más lento)
let preSumTime = 0; // Tiempo de preanimación para la suma
let managedSounds = [];
function preload() {
  soundFormats('mp3');
  
  // Usamos las variables globales definidas en p5.html
  rotateStartSound = loadSound(rotateStartSoundURL);
  rotateEndSound = loadSound(rotateEndSoundURL);
  managedSounds.push(rotateStartSound, rotateEndSound);
}



/**
 * Reproduce un sonido de forma segura, evitando que se ejecute si
 * otro sonido gestionado ya está sonando.
 * @param {p5.SoundFile} sound - El objeto de sonido de p5.js que se quiere reproducir.
 */
function playSound(sound) {
  // Primero, verificar que el sonido exista y esté cargado.
  if (!sound || !sound.isLoaded()) {
    console.log("El sonido aún no está listo.");
    return;
  }

  // Segundo, recorrer la lista de sonidos gestionados.
  for (let s of managedSounds) {
    // Si algún sonido de la lista ya está sonando...
    if (s.isPlaying()) {
      // ...no hacer nada y salir de la función.
      return;
    }
  }

  // Si el bucle termina, significa que no hay sonidos en curso.
  // Ahora sí, reproducir el sonido solicitado.
  sound.play();
}

function setup() {
  let canvas = createCanvas(900, 600);
  canvas.parent('sketch-holder');
  background(220);

  textSize(18);
  textAlign(LEFT, CENTER);
  fill(0);

  let yPos = 20;
  let xPos = 20;

  createElement('h3', 'Configuración del Campo Finito (Zp)').position(xPos, yPos).addClass('p5-label');
  yPos += 40;

  createP('Módulo p (primo):').position(xPos, yPos).addClass('p5-label');
  yPos += 40; // Añadimos más espacio entre el label y el input
  inputP = createInput(modulusP.toString());
  inputP.position(xPos, yPos);
  inputP.input(updateValues);
  inputP.addClass('p5-input');
  yPos += 45; // Espacio extra después del input

  createP('Número 1 (a):').position(xPos, yPos).addClass('p5-label');
  yPos += 40;
  inputNum1 = createInput(val1.toString());
  inputNum1.position(xPos, yPos);
  inputNum1.input(updateValues);
  inputNum1.addClass('p5-input');
  yPos += 45;

  createP('Número 2 (b):').position(xPos, yPos).addClass('p5-label');
  yPos += 40;
  inputNum2 = createInput(val2.toString());
  inputNum2.position(xPos, yPos);
  inputNum2.input(updateValues);
  inputNum2.addClass('p5-input');
  yPos += 45;

  let calculateButton = createButton('Calcular suma');
  calculateButton.position(xPos, yPos);
  calculateButton.mousePressed(() => triggerAnimation("sum"));
  yPos += 45;

  let multButton = createButton('Calcular multiplicación');
  multButton.position(xPos, yPos);
  multButton.mousePressed(() => triggerAnimation("mult"));
  yPos += 45;

  let speedSlider = createSlider(0.1, 2, 0.5, 0.01); // mínimo más bajo y valor inicial más lento
  speedSlider.position(20, yPos + 50);
  speedSlider.style('width', '200px');
  speedSlider.input(() => {
    animationSpeed = speedSlider.value();
  });
  createP('Velocidad de animación').position(20, yPos + 10).addClass('p5-label');

  updateValues();
}

function triggerAnimation(type) {
  animating = true;
  animationStart = millis();
  animationProgress = 0;
  animationType = type || "sum"; // "sum" o "mult"
  updateValues();
  loop();
}

function updateValues() {
  // Obtener valores de los inputs y convertirlos a enteros
  let newP = parseInt(inputP.value());
  let newNum1 = inputNum1.value();
  let newNum2 = inputNum2.value();

  // Validar el módulo p: debe ser un número y mayor que 1
  if (isNaN(newP) || newP <= 1) {
    modulusP = 2;
    inputP.value(modulusP);
  } else {
    modulusP = newP;
  }

  // Validar Número 1 (a)
  if (newNum1 === "") {
    val1 = 0;
    inputNum1.value(""); // No mostrar nada si está vacío
  } else {
    let parsedNum1 = parseInt(newNum1);
    if (isNaN(parsedNum1) || parsedNum1 < 0 || parsedNum1 >= modulusP) {
      val1 = 0;
      inputNum1.value("0");
    } else {
      val1 = parsedNum1;
      inputNum1.value(parsedNum1.toString());
    }
  }

  // Validar Número 2 (b)
  if (newNum2 === "") {
    val2 = 0;
    inputNum2.value(""); // No mostrar nada si está vacío
  } else {
    let parsedNum2 = parseInt(newNum2);
    if (isNaN(parsedNum2) || parsedNum2 < 0 || parsedNum2 >= modulusP) {
      val2 = 0;
      inputNum2.value("0");
    } else {
      val2 = parsedNum2;
      inputNum2.value(parsedNum2.toString());
    }
  }

  sumResult = (val1 + val2) % modulusP;
  multResult = (val1 * val2) % modulusP;

  redraw();
}

function draw() {
  background(220);

  

  drawModularClock();

  if (animating) {
    let duration = 1800 / animationSpeed;
    let pause = 350 / animationSpeed;
    let elapsed = millis() - animationStart;
    let progress = constrain(elapsed / duration, 0, 1);

    let p1 = 0.33;
    let p2 = p1 + (pause / duration);
    let p3 = 0.66 + (pause / duration);
    let p4 = 0.9 + (pause / duration);
    if (p4 > 0.9) p4 = 0.9;

    if (animationType === "sum") {
      animateSumPie(progress, p1, p2, p3, p4);
    }

    if (animationType === "mult") {
      animateMultPie(progress);
    }

    if (elapsed >= duration) {
      animating = false;
      noLoop();
    }
  }



  push(); // Guarda el estado actual de estilos
  fill(0);
  noStroke();
  textSize(20);
  textAlign(LEFT, CENTER);
  text(`Módulo (p): ${modulusP}`, 600, 50);
  text(`Número 1 (a): ${val1}`, 600, 80);
  text(`Número 2 (b): ${val2}`, 600, 110);

  fill(0, 150, 0);
  textAlign(RIGHT, CENTER);
  text(`Suma Modular (a + b) mod p: (${val1} + ${val2}) mod ${modulusP} = ${sumResult}`, 880, 160);
  text(`Multiplicación Modular (a * b) mod p: (${val1} * ${val2}) mod ${modulusP} = ${multResult}`, 880, 190);
  pop(); // Restaura el estado anterior de estilos
}

function drawModularClock() {
  let centerX = width / 2;
  let centerY = height / 2 + 100;
  let radius = 150;

  stroke(0);
  strokeWeight(2);
  noFill();
  ellipse(centerX, centerY, radius * 2, radius * 2);

  textSize(16);
  textAlign(CENTER, CENTER);
  fill(0);

  for (let i = 0; i < modulusP; i++) {
    let angle = map(i, 0, modulusP, 0, TWO_PI) - HALF_PI;
    let x = centerX + cos(angle) * (radius + 20);
    let y = centerY + sin(angle) * (radius + 20);
    text(i, x, y);

    let xInner = centerX + cos(angle) * radius;
    let yInner = centerY + sin(angle) * radius;
    let xOuter = centerX + cos(angle) * (radius + 10);
    let yOuter = centerY + sin(angle) * (radius + 10);
    line(xInner, yInner, xOuter, yOuter);
  }

  highlightNumber(val1, centerX, centerY, radius, color(255, 0, 0));
  highlightNumber(val2, centerX, centerY, radius, color(0, 0, 255));
  highlightNumber(sumResult, centerX, centerY, radius, color(0, 150, 0));
  highlightNumber(multResult, centerX, centerY, radius, color(200, 100, 0)); // Resaltar el resultado de la multiplicación modular

  drawLineToNumber(val1, centerX, centerY, radius, color(255, 0, 0, 100));
  drawLineToNumber(val2, centerX, centerY, radius, color(0, 0, 255, 100));
  drawLineToNumber(sumResult, centerX, centerY, radius, color(0, 150, 0, 100));
  drawLineToNumber(multResult, centerX, centerY, radius, color(200, 100, 0, 100)); // Línea para la multiplicación modular
}

function highlightNumber(num, centerX, centerY, radius, highlightColor) {
  if (num >= 0 && num < modulusP) {
    let angle = map(num, 0, modulusP, 0, TWO_PI) - HALF_PI;
    let x = centerX + cos(angle) * radius;
    let y = centerY + sin(angle) * radius;

    fill(highlightColor);
    noStroke();
    ellipse(x, y, 20, 20);
  }
}

function drawLineToNumber(num, centerX, centerY, radius, lineColor) {
  if (num >= 0 && num < modulusP) {
    let angle = map(num, 0, modulusP, 0, TWO_PI) - HALF_PI;
    let x = centerX + cos(angle) * radius;
    let y = centerY + sin(angle) * radius;

    stroke(lineColor);
    strokeWeight(3);
    line(centerX, centerY, x, y);
  }
}

function animateSumLine(progress) {
  let centerX = width / 2;
  let centerY = height / 2 + 100;
  let radius = 150;

  // Calcula los ángulos
  let angleA = map(val1, 0, modulusP, 0, TWO_PI) - HALF_PI;
  let angleB = map(val2, 0, modulusP, 0, TWO_PI) - HALF_PI;
  let angleSum = map(sumResult, 0, modulusP, 0, TWO_PI) - HALF_PI;

  // Punto de inicio (centro)
  let x0 = centerX;
  let y0 = centerY;

  // Punto de val1
  let x1 = centerX + cos(angleA) * radius;
  let y1 = centerY + sin(angleA) * radius;

  // Punto de sumResult
  let x2 = centerX + cos(angleSum) * radius;
  let y2 = centerY + sin(angleSum) * radius;

  stroke(0, 150, 0);
  strokeWeight(5);

  if (progress < 0.5) {
    // Animar desde centro a val1
    let t = map(progress, 0, 0.5, 0, 1);
    let xt = lerp(x0, x1, t);
    let yt = lerp(y0, y1, t);
    line(x0, y0, xt, yt);
  } else {
    // Animar desde val1 a sumResult
    line(x0, y0, x1, y1);
    let t = map(progress, 0.5, 1, 0, 1);
    let xt = lerp(x1, x2, t);
    let yt = lerp(y1, y2, t);
    line(x1, y1, xt, yt);
  }
}

function animateSumPie(progress) {
  push();
  let centerX = width / 2;
  let centerY = height / 2 + 100;
  let radius = 150;

  // --- Asignación de valores y colores ---
  let firstVal = Math.min(val1, val2);
  let secondVal = Math.max(val1, val2);
  let firstColor = (val1 <= val2) ? color(255, 0, 0, 150) : color(0, 0, 255, 150);
  let secondColor = (val1 > val2) ? color(255, 0, 0, 150) : color(0, 0, 255, 150);

  let angleFirst = map(firstVal, 0, modulusP, 0, TWO_PI);
  let angleSecond = map(secondVal, 0, modulusP, 0, TWO_PI);

  // --- Definición de las Fases de la Animación ---
  const phase1_end = 0.30; // Termina la animación del primer arco
  const phase2_end = 0.60; // Termina la animación del segundo arco
  const pause_end = 0.80;  // Termina la pausa (dura un 20% del total)
  const rotation_end = 1.0;  // Termina la rotación

  // --- Cálculo de los valores animados basado en el progreso ---

  // 1. Ángulo del primer arco
  let currentAngleFirst = (progress < phase1_end) ? lerp(0, angleFirst, progress / phase1_end) : angleFirst;

  // 2. Ángulo del segundo arco (solo se anima después de la fase 1)
  let currentAngleSecond = 0;
  if (progress > phase1_end) {
    let t = (progress - phase1_end) / (phase2_end - phase1_end);
    t = constrain(t, 0, 1); // Limita t entre 0 y 1
    currentAngleSecond = lerp(0, angleSecond, t);
  }
  
  // 3. Rotación (solo se anima después de la pausa)
  let rotationAngle = 0;
  if (progress > pause_end) {
    playSound(rotateStartSound);
    let t = (progress - pause_end) / (rotation_end - pause_end);
    t = constrain(t, 0, 1);
    rotationAngle = lerp(0, angleFirst, t);
  }

  // --- Dibujar los elementos en orden ---

  // Siempre dibuja el primer arco (rojo)
  fill(firstColor);
  noStroke();
  arc(centerX, centerY, radius * 2, radius * 2, -HALF_PI, -HALF_PI + currentAngleFirst, PIE);
  
  // Dibuja el segundo arco (azul) encima, aplicando la rotación
  if (currentAngleSecond > 0) {
    fill(secondColor);
    noStroke();
    let startAngle = -HALF_PI + rotationAngle;
    let endAngle = startAngle + currentAngleSecond;
    arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);
  }

  // Resalta el punto final solo cuando la animación ha terminado
  if (progress >= 1) {
    rotateStartSound.stop(); // Detiene el sonido de inicio si estaba sonando
    playSound(rotateEndSound);    
    let angleSum = map((val1 + val2) % modulusP, 0, modulusP, 0, TWO_PI) - HALF_PI;
    let xSum = centerX + cos(angleSum) * radius;
    let ySum = centerY + sin(angleSum) * radius;
    noFill();
    stroke(0);
    strokeWeight(3);
    ellipse(xSum, ySum, 24, 24);
  }

  pop();
}
function animateMultPie(progress) {
  push();
  let centerX = width / 2;
  let centerY = height / 2 + 100;
  let radius = 150;

  let sliceVal = Math.min(val1, val2);
  let rotVal = Math.max(val1, val2);
  let angleSlice = map(sliceVal, 0, modulusP, 0, TWO_PI);

  // Definimos 3 fases: dibujar, pausar y rotar.
  let drawPhaseEnd = 0.35;   // El dibujo termina en el 35%
  let pausePhaseEnd = 0.55;  // La pausa termina en el 55% (dura un 20% del total)
  let rotatePhaseEnd = 1.0;    // La rotación ocupa el resto

  // Fase 1: Animar el trozo
  if (progress < drawPhaseEnd) {
    let t = progress / drawPhaseEnd; // Progreso dentro de esta fase (0 a 1)
    let endAngle = lerp(-HALF_PI, -HALF_PI + angleSlice, t);
    
    fill(255, 140, 0, 150);
    noStroke();
    arc(centerX, centerY, radius * 2, radius * 2, -HALF_PI, endAngle, PIE);
    
  } 
  // Fase 2: Pausa (dibuja el arco completo pero sin movimiento)
  else if (progress < pausePhaseEnd) {
    let startAngle = -HALF_PI;
    let endAngle = startAngle + angleSlice;
    
    fill(255, 140, 0, 150);
    noStroke();
    arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);
    
  } 
  // Fase 3: Rotar el trozo ya formado
  else {
    playSound(rotateStartSound);    
    // Progreso dentro de esta fase (0 a 1)
    let t = (progress - pausePhaseEnd) / (rotatePhaseEnd - pausePhaseEnd);
    
    // --- INICIO DE LA CORRECCIÓN ---
    // Interpolamos el NÚMERO de la rotación, de la 1ª a la n-ésima (rotVal).
    let currentRotationStep = lerp(1, rotVal, t);
    
    // La posición inicial del arco es el número de la rotación MENOS UNO,
    // multiplicado por el tamaño del arco.
    let startAngle = -HALF_PI + (currentRotationStep - 1) * angleSlice;
    let endAngle = startAngle + angleSlice;
    // --- FIN DE LA CORRECCIÓN ---
    
    fill(255, 140, 0, 150);
    noStroke();
    arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, PIE);
  }

  // Resalta el resultado final cuando la animación completa termina
  if (progress >= 1) {
    rotateStartSound.stop(); // Detiene el sonido de inicio si estaba sonando
    playSound(rotateEndSound);
    let angleResult = map(multResult, 0, modulusP, 0, TWO_PI) - HALF_PI;
    let xRes = centerX + cos(angleResult) * radius;
    let yRes = centerY + sin(angleResult) * radius;
    
    noFill();
    stroke(0);
    strokeWeight(3);
    ellipse(xRes, yRes, 24, 24);
  }
  
  pop();
}
    </script>
</body>
</html>